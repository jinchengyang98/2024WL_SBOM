import sys
import os
import requests
import logging
import json
import argparse
from typing import List, Dict
import time
from datetime import datetime, timedelta
from config import config

# 配置路径
NVD_DATA_PATH = config.NVD_DATA_PATH
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '.'))) # 将包含模块的目录添加到Python路径中（需要绝对路径）

# 删除不再需要的 import
# from vulnerability_data_storage import store_data

logging.basicConfig(level=logging.INFO)

class VulnerabilityDataCollector:
    def __init__(self, sources: Dict):
        self.sources = sources

    def fetch_data_from_source(self, source_name: str, source_info: Dict) -> List[Dict]:
        all_data = []
        params = source_info["params"].copy()
        max_results = source_info.get("pagination", {}).get("max_results", float('inf'))
        delay = source_info.get("pagination", {}).get("delay_between_requests", 6)

        start_date = datetime.strptime(params['pubStartDate'], "%Y-%m-%dT%H:%M:%S.%f")
        end_date = datetime.strptime(params['pubEndDate'], "%Y-%m-%dT%H:%M:%S.%f")

        while start_date < end_date and len(all_data) < max_results:
            current_end_date = min(start_date + timedelta(days=120), end_date)
            params['pubStartDate'] = start_date.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]
            params['pubEndDate'] = current_end_date.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3]

            while True:
                try:
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                    }
                    
                    logging.info(f"向 {source_info['url']} 发送请求，参数为: {params}")
                    response = requests.get(source_info["url"], params=params, headers=headers, timeout=30)
                    
                    logging.info(f"响应状态码: {response.status_code}")
                    
                    response.raise_for_status()
                    
                    data = response.json()
                    
                    if source_name == "NVD":
                        vulnerabilities = data.get('vulnerabilities', [])
                        all_data.extend(vulnerabilities)
                        
                        total_results = data.get('totalResults', 0)
                        start_index = params.get('startIndex', 0)
                        results_per_page = params.get('resultsPerPage', 100)
                        
                        logging.info(f"获取到 {len(vulnerabilities)} 个漏洞。总计: {len(all_data)}/{total_results}")
                        
                        if start_index + results_per_page >= total_results:
                            break
                        
                        params['startIndex'] = start_index + results_per_page
                    else:
                        break

                    time.sleep(delay)

                except requests.exceptions.RequestException as e:
                    logging.error(f"从 {source_name} 获取数据时出错: {e}")
                    break
                except json.JSONDecodeError as e:
                    logging.error(f"解析来自 {source_name} 的JSON时出错: {e}")
                    break

            start_date = current_end_date + timedelta(seconds=1)

        return all_data

    def save_data_to_json(self, source_name: str, data: List[Dict]):
        for item in data:
            # 获取漏洞的发布年份
            published_date = item.get('cve', {}).get('published', '')
            if published_date:
                year = datetime.strptime(published_date, "%Y-%m-%dT%H:%M:%S.%f").year
            else:
                year = datetime.now().year

            # 创建年份文件夹
            year_folder = os.path.join(NVD_DATA_PATH, str(year))
            os.makedirs(year_folder, exist_ok=True)

            # 生成文件名（使用CVE ID或其他唯一标识符）
            cve_id = item.get('cve', {}).get('id', 'unknown')
            filename = f"{cve_id}.json"
            file_path = os.path.join(year_folder, filename)

            # 保存数据到JSON文件
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(item, f, ensure_ascii=False, indent=2)

            logging.info(f"保存 {cve_id} 到 {file_path}")

    def fetch_all_data(self) -> Dict[str, List[Dict]]:
        all_data = {}
        for source_name, source_info in self.sources.items():
            logging.info(f"正在从 {source_name} 获取数据")
            data = self.fetch_data_from_source(source_name, source_info)
            all_data[source_name] = data
            # 保存数据到JSON文件
            self.save_data_to_json(source_name, data)
        return all_data

def main():
    parser = argparse.ArgumentParser(description="漏洞数据收集器")
    parser.add_argument('--config', type=str, default='config/config_nvd_github.json', help='配置文件的路径')
    args = parser.parse_args()

    # 获取脚本的绝对路径
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # 构造配置文件的完整路径
    config_path = os.path.join(script_dir, args.config)

    if not os.path.exists(config_path):
        logging.error(f"未找到配置文件: {config_path}")
        return

    with open(config_path, 'r', encoding='utf-8') as file:
        config = json.load(file)

    collector = VulnerabilityDataCollector(config.get("sources", {}))
    all_vulnerability_data = collector.fetch_all_data()
    for source, data in all_vulnerability_data.items():
        logging.info(f"从 {source} 获取到 {len(data)} 条记录。")
        # 数据已经在 fetch_all_data 方法中保存，这里不需要额外操作

if __name__ == "__main__":
    main()